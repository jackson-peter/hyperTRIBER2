
#' Generate count files and GFF annotation for DEXSeq
#'
#' Reshapes per-sample count data into DEXSeq-compatible format:
#' one row per site×base combination, then writes count tables
#' and a fake GFF annotation file.
#'
#' @param data_list Named list of tibbles from extract_count_data / restrict_data
#' @param design_vector Character vector: "treat" or "control" per sample
#' @param out_dir Output directory (created if needed)
#' @param stranded Logical
#' @return Invisibly returns the annotation tibble
#' @export
generate_count_files <- function(data_list,
                                 design_vector,
                                 out_dir,
                                 stranded = FALSE) {

  bases <- c("A", "T", "C", "G")
  dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)

  # -- 1. Reshape each sample: wide to long (site_id:base -> count) -----------
  counts_long <- purrr::imap(data_list, function(df, samp_name) {
    # Build long format: one row per site × base
    tidyr::pivot_longer(
      df,
      cols      = all_of(bases),
      names_to  = "base",
      values_to = "count"
    ) |>
      dplyr::mutate(
        row_id = paste0(site_id, ":", base)
      ) |>
      dplyr::select(row_id, count)
  })

  # -- 2. Write count files --------------------------------------------------
  treat_idx   <- which(design_vector == "treat")
  control_idx <- which(design_vector == "control")

  write_counts <- function(indices, prefix) {
    for (k in indices) {
      samp_name <- names(counts_long)[k]
      out_file <- file.path(out_dir, paste0("counts_", prefix, "_", samp_name, ".txt"))
      write.table(
        counts_long[[k]] |> tibble::column_to_rownames("row_id"),
        file = out_file,
        col.names = FALSE, row.names = TRUE, quote = FALSE, sep = "\t"
      )
    }
  }


  write_counts(treat_idx,   "Treat")
  write_counts(control_idx, "Control")

  # -- 3. Build GFF annotation for DEXSeq ------------------------------------
  # Use metadata from first sample (all samples share same sites)
  ref_df <- data_list[[1]]

  annotation <- tidyr::pivot_longer(
    ref_df,
    cols      = all_of(bases),
    names_to  = "base",
    values_to = "count"
  ) |>
    dplyr::mutate(
      row_id = paste0(site_id, ":", base),
      gene_id = if (stranded) paste0(chr, "_", pos, ",", strand) else paste0(chr, "_", pos),
      v9 = paste0(
        "transcripts ", row_id, "; ",
        "exonic_part_number ", base, "; ",
        "gene_id ", gene_id
      )
    ) |>
    dplyr::transmute(
      col1 = chr,
      col2 = row_id,
      col3 = "exonic_part",
      col4 = pos,
      col5 = pos,
      col6 = ".",
      col7 = if (stranded) strand else "*",
      col8 = ".",
      col9 = v9
    )

  write.table(
    annotation,
    file = file.path(out_dir, "annotation_file_made_up_for_DEXSeq.gff"),
    col.names = FALSE, row.names = FALSE, quote = FALSE, sep = "\t"
  )

  message(glue::glue(
    "Written {length(treat_idx)} treat + {length(control_idx)} control count files ",
    "and annotation GFF to {out_dir}"
  ))

  invisible(annotation)
}







#' Run DEXSeq differential exon usage test
#'
#' Wraps the full DEXSeq pipeline: reads count files generated by
#' generate_count_files(), estimates size factors, dispersions,
#' tests for differential usage, and estimates fold changes.
#'
#' @param out_dir Directory containing count files and GFF from generate_count_files()
#' @param design_vector Character vector of "control"/"treat" per sample
#' @param n_cores Integer, number of cores for parallel steps
#' @param fit_type Dispersion fit type passed to estimateDispersions()
#' @param save_results Logical, whether to save .Rdat to out_dir
#' @return DEXSeqResults object
#' @export
make_test <- function(out_dir,
                      design_vector,
                      n_cores = 1,
                      fit_type = "local",
                      save_results = TRUE) {

  # -- 1. Collect input files ------------------------------------------------
  count_files    <- sort(list.files(out_dir, pattern = "^counts.*\\.txt$", full.names = TRUE))
  flattened_file <- list.files(out_dir, pattern = "\\.gff$", full.names = TRUE)

  stopifnot(
    "No count files found"    = length(count_files) > 0,
    "No GFF file found"       = length(flattened_file) == 1,
    "Count files don't match design" = length(count_files) == length(design_vector)
  )

  # -- 2. Build sample table -------------------------------------------------
  # Count files are sorted alphabetically: countsControl1, countsControl2, ..., countsTreat1, ...
  # So sample table must match that order: controls first, then treats
  n_control <- sum(design_vector == "control")
  n_treat   <- sum(design_vector == "treat")

  sample_table <- data.frame(
    row.names = c(
      paste0("control_", seq_len(n_control)),
      paste0("treat_",   seq_len(n_treat))
    ),
    condition = c(
      rep("control", n_control),
      rep("treat",   n_treat)
    )
  )

  message("Running DEXSeq with ", n_control, " control + ", n_treat, " treat samples")

  # -- 3. DEXSeq pipeline ----------------------------------------------------
  bp_param <- BiocParallel::MulticoreParam(workers = n_cores)

  dxd <- DEXSeq::DEXSeqDataSetFromHTSeq(
    countfiles    = count_files,
    sampleData    = sample_table,
    design        = ~ sample + exon + condition:exon,
    flattenedfile = flattened_file
  )

  message("Estimating size factors...")
  dxd <- DEXSeq::estimateSizeFactors(dxd)

  message("Estimating dispersions...")
  dxd <- DEXSeq::estimateDispersions(dxd, fitType = fit_type, BPPARAM = bp_param)

  message("Testing for differential exon usage...")
  dxd <- DEXSeq::testForDEU(dxd, BPPARAM = bp_param)

  message("Estimating fold changes...")
  dxd <- DEXSeq::estimateExonFoldChanges(dxd, fitExpToVar = "condition", BPPARAM = bp_param)

  res <- DEXSeq::DEXSeqResults(dxd)

  # -- 4. Optionally save ----------------------------------------------------
  if (save_results) {
    save_path <- file.path(out_dir, "dxd_results.Rdat")
    save(res, file = save_path)
    message("Results saved to ", save_path)
  }

  return(res)
}
